\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{indentfirst}

\usepackage{tikz}
\usepackage{pgfplots}

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискрeтного анализа: сортировка за линейное время}

\noindent Выполнил студент группы 08-208 МАИ \textit{Былькова Кристина}.

\subsection*{Условие}

\begin{itemize}
\item \textbf{Общая постановка задачи:} Требуется разработать программу, осуществляющую ввод пар «ключ-значение», их упорядочивание по возрастанию ключа указанным алгоритмом сортировки за линейное время и вывод отсортированной последовательности.

\item \textbf{Вариант сортировки:} Поразрядная сортировка

\item \textbf{Вариант ключа:} MD5-суммы (32-разрядные шестнадцатиричные числа)

\item \textbf{Вариант значения:} Строки переменной длины (до 2048 символов)
\end{itemize}

\subsection*{Метод решения}

Моя сортировка реализована в функции void RadixSort(TVector<TItem> \&vec), которая принимает на вход вектор и сортирует его. Общий алгоритм поразрядной сортировки основан на том, что числа сортируются не целиком, а лишь значения их разрядов.

Я рассматривала каждый символ всех ключей, начиная с наименьшего разряда (LSD \textbf{--} least significant digit) и сортировала набор этих символов сортировкой подсчетом. 

Для начала в массив count записывала количество элементов, попадающих в каждую "корзину" (определенную текущим разрядом) на основе их ключей. Далее обновляла счетчики в массиве count так, чтобы каждый счетчик содержал количество элементов, не превышающих индекс текущей "корзины". Это необходимо для последующего правильной расстановки элементов в выходном векторе. В следующем цикле размещала элементы в правильную позицию во временном векторе output. А последний цикл необходим для копирования отсортированных элементов из временного output обратно в исходный vec. Затем, переходила к следующему разряду и повторяла действия.

\subsection*{Описание программы}
Были написаны два класса и структура:
\begin{itemize}
\item class Tvector \textbf{--} собственная реализация вектора с произвольным типом
\item class TString \textbf{--} собственная реализация строки
\item struct TItem \textbf{--} структура для хранения пары ключ-значение. Ключи — это 32-разрядные шестнадцатиричные числа, представленные в виде массивов типа char. Значения - это порядковые номера изначально вводимых строк.
\end{itemize}

Для выполнения задания я использовала:
\begin{itemize}
\item TVector<TItem> vec \textbf{--} вектор, где хранятся пары ключ-значения. Не храню тут строки, так как при сортировке копировать строки будет очень долго и затратно.

\item TVector<TString> strv \textbf{--} вектор, где хранятся строки переменной длины до 2048 символов. 
\end{itemize}
Изначально считываются все входные данные, затем сортируется основной вектор, в конце — вывод отсортированного вектора.

\subsection*{Дневник отладки}

Основными проблемами были большой объем занимаемой памяти и превышение лимита скорости работы программы. Изначально в сортировку поступал вектор типа TItem, где ключом было 32-разрядное шестнадцатиричное число, а значением — строка переменной длины. Перемещение строк очень затратно, поэтому в векторе, который сортирую, я стала хранить лишь их порядковые номера. Сами же строки находятся в другом векторе, и при выводе я просто устанавливаю нужный индекс. Это и стало решением проблемы, так как с такой реализацией программа зашла на вердикт ОК.

Также в первой версии программы я установила максимальный размер строк 2048, что приводило к выходу за границы. Исправила, поменяв размер на 2049.

\subsection*{Тест производительности}

Для проверки производительности алгоритма я использовала сравнение со стандартной сортировкой std::sort, сложность которой ${O}({n}\log n)$.
Сравнение производилось на входных данных больших размеров, не превышающих ${10^6}$. 

Исходя из графика, представленного ниже, можно увидеть, что сложность моей поразрядной сортировки близка к линейной, так как количество разрядов в моём задании всегда одинаково.
Однако стандартная сортировка std::sort оказывается намного эффективнее. Я думаю. что это связано с форматом входных данных в моём варианте, ведь сортировка происходит по ключу, тип которого \textbf{--} массив char, а не по числам.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Объём входных данных ($\times 10^6$)},
            ylabel={Время работы (ms)},
            grid=major,
            xmin=0, xmax=1,
            ymin=0, ymax=1200,
            xtick={0,0.2,0.4,0.6,0.8,1},
            ytick={0,200,400,600,800,1000,1200},
            legend style={at={(0.5,-0.2)},anchor=north},
            legend columns=2,
            width=0.8\textwidth,
            height=0.5\textwidth,
            ]
            \addplot[color=red,mark=*] coordinates {
                (0,0)
                (0.1,105.0078)
                (0.2,223.0410)
                (0.4,459.3861)
                (0.6,676.7451)
                (0.8,901.3387)
                (1,1129.0011)
            };
            \addlegendentry{RadixSort}
            \addplot[color=green,mark=square] coordinates {
                (0,0)
                (0.1,25.7336)
                (0.2,55.6141)
                (0.4,113.0662)
                (0.6,175.1385)
                (0.8,242.5044)
                (1,302.6065)
            };
            \addlegendentry{std::sort}
        \end{axis}
    \end{tikzpicture}
    \label{fig:graph}
\end{figure}

\newpage
\subsection*{Выводы}

%Описать область применения реализованного алгоритма. Указать типовые задачи, решаемые им. Оценить сложность программирования, кратко описать возникшие проблемы при решении задачи. 

В результате данной лабораторной работы была написана и отлажена программа на языке C++, осуществляющая ввод пар «ключ-значение», их упорядочивание по возрастанию ключа алгоритмом поразрядной сортировки за линейное время и вывод отсортированной последовательности. Также были написаны аналоги стандартных контейнеров, таких как вектор и строка.

Сложность моей поразрядной сортировки: ${O}$(n$\cdot$k), где n \textbf{--} количество ключей, а k \textbf{--} количество разрядов в каждом ключе (32 разряда). В связи с тем, что количество разрядов константа, сложность получается линейной.

Данный алгоритм эффективен для быстрого поиска данных, ключи у которых являются MD5-суммами. Также, в связи с тем, что MD5-суммы используются для проверки целостности информации, моя программа может быть полезна для оптимального отслеживания побитых файлов. 

\end{document}
