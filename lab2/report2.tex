\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{indentfirst}

\usepackage[figurename=Fig.]{caption}
\usepackage{tikz}
\usepackage{pgfplots}

\begin{document}

\section*{Лабораторная работа №\,2 по курсу дискрeтного анализа: сбалансированные деревья}

\noindent Выполнил студент группы 08-208 МАИ \textit{Былькова Кристина}.

\subsection*{Условие}
\textbf{Общая постановка задачи:} Необходимо создать программную библиотеку, реализующую указанную структуру данных, на основе которой разработать программу-словарь. В словаре каждому ключу, представляющему из себя регистронезависимую последовательность букв английского алфавита длиной не более 256 символов, поставлен в соответствие некоторый номер, от 0 до ${2^{64} - 1}$. Разным словам может быть поставлен в соответствие один и тот же номер.

Программа должна обрабатывать строки входного файла до его окончания. Каждая строка может иметь следующий формат:
\begin{itemize}
\item+ word 34 — добавить слово «word» с номером 34 в словарь. Программа должна вывести строку «OK», если операция прошла успешно, «Exist», если слово уже находится в словаре.
\item- word — удалить слово «word» из словаря. Программа должна вывести «OK», если слово существовало и было удалено, «NoSuchWord», если слово в словаре не было найдено.
\itemword — найти в словаре слово «word». Программа должна вывести «OK: 34», если слово было найдено; число, которое следует за «OK:» — номер, присвоенный слову при добавлении. В случае, если слово в словаре не было обнаружено, нужно вывести строку «NoSuchWord».
\item! Save /path/to/file — сохранить словарь в бинарном компактном представлении на диск в файл, указанный парамером команды. В случае успеха, программа должна вывести «OK», в случае неудачи выполнения операции, программа должна вывести описание ошибки (см. ниже).
\item! Load /path/to/file — загрузить словарь из файла. Предполагается, что файл был ранее подготовлен при помощи команды Save. В случае успеха, программа должна вывести строку «OK», а загруженный словарь должен заменить текущий (с которым происходит работа); в случае неуспеха, должна быть выведена диагностика, а рабочий словарь должен остаться без изменений. Кроме системных ошибок, программа должна корректно обрабатывать случаи несовпадения формата указанного файла и представления данных словаря во внешнем файле.
\end{itemize}

\textbf{Вариант структуры данных:} AVL-дерево

\subsection*{Метод решения}

Моя программа обрабатывает строки входного файла до его окончания, при этом я разделяю ввод команды, ключа и значения. В зависимости от команды обрабатываю следющие входные данные. Например, если команда = "+", далее я считываю ключ и значение, проверяю, есть ли такое слово в моём словаре. Если нет - добавляю в дерево, иначе вывожу сообщение в соответствие с требованиями. 
Прежде всего, AVL-дерево — это сбалансированное двоичное дерево поиска, в котором поддерживается следующее свойство: для каждой его вершины высота её двух поддеревьев различается не более чем на 1. Из-за этого при всех манипуляциях с деревом, необходимо проверять это свойство. И в случае его невыполнения производить балансировку, путем поворотов. Для этого у меня написаны такие функции, как:
\begin{itemize}
\item int BFactor(TNode *tree) \textbf{--} возвращает разницу между высотам поддеревьев  
\item TNode *RightRotate(TNode *tree) \textbf{--} поворот правого поддерева
\item TNode *LeftRotate(TNode *tree) \textbf{--} поворот левого поддерева
\item TNode *Balance(TNode *tree) \textbf{--} балансировка дерева
\end{itemize}

Поиск в AVL-дереве основан на поиске в обычном двоичном дереве поиска: спускаемся по дереву и сравниваем значение искомого узла с текущим. В зависимости от сравнения, идем по левому или правому поддереву.

Вставка в AVL-дерево основана на том, что мы спускаемся по дереву, на каждом шаге сравнивая значение нового узла с текущими. Затем, доходим до конца какого-либо поддерева и делаем новый узел правым или левым его потомком в зависимости от значения. При этом не забываем про балансировку.

Для удаления узла из AVL-дерева сначала в дереве ищем узел, который нужно удалить. Если такого узла нет, ничего не делается. Если узел находится, то надо пройти по правому поддереву удаляемого узла и найти в нем узел с самым маленьким значением —  min. После этого удаляемый узел нужно заменить на узел min, и структура дерева перестроится. Если правого поддерева у удаляемого узла нет, вместо min на место узла подставляется его левый потомок. Если левого потомка тоже нет, значит, удаляемый узел — лист, то есть потомки у него отсутствуют в принципе. Тогда его можно просто удалить и ничего не подставлять на его место. После всех этих манипуляций, также не забываем про балансировку.

\subsection*{Описание программы}
Были написаны два класса и структура:
\begin{itemize}
\item class TString \textbf{--} собственная реализация строки
\item class TAVLTree \textbf{--} реализация AVL-дерева
\item struct TNode \textbf{--} структура вершины дерева, предназначенная в том числе для хранения пары ключ-значение.
\end{itemize}

Для выполнения задания я использовала:
\begin{itemize}
\item TAVLTree<TString, unsigned long long> tree \textbf{--} словарь в виде AVL-дерева, где хранятся пары ключ-значения. 
\end{itemize}

\subsection*{Дневник отладки}

Основной проблемой было то, что я невнимательно прочитала задание и неверно считывала входные данные, что приводило к зацикливанию программы, а, следовательно, к превышению лимита времени.
Также небольшую сложность вызвало написание оператора для ввода в собственном классе TString.

\subsection*{Тест производительности}

Для проверки производительности моего словаря в виде AVL-дерева я использовала сравнение со стандартным контейнером std::map. Это имеет смысл так как в его основе лежит красно-черное дерево, которое тоже является сбалансированным.
Сравнение производилось на входных данных больших размеров, не превышающих ${10^5}$. 

Исходя из графика, представленного ниже, можно увидеть, что вставка (аналогично с удалением) элементов в std::map работает быстрее, чем в AVL-дереве, а с поиском ситуация противоположна. Это происходит в силу различий в алгоритмах балансировки: в красно-черных деревьях она происходит гораздо реже, чем в AVL-дереве. Как следствие вставка (удаление) происходит быстрее. Однако высота красно-черного дерева больше высоты соответствующего AVL-дерева. Отсюда вытекает большее время поиска.
Не логарифмическая зависимость на графиках, по моему мнению, получается из-за довольно частых выделений/освобождений памяти на кучи, а это, как известно, не дешевая в плане времени операция. К тому же графики имеют очень похожую форму, что говорит об асимптотически одинаковой скорости роста времени выполнения операций.

\begin{figure}[htbp]
    \centering
    \caption*{Вставка} 
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Объём входных данных ($\times 10^5$)},
            ylabel={Время работы (ms)},
            grid=major,
            xmin=0, xmax=1,
            ymin=0, ymax=5000,
            xtick={0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1},
            ytick={0,500,1000,1500,2000,2500,3000,3500,4000,4500,5000},
            legend style={at={(0.5,-0.2)},anchor=north},
            legend columns=2,
            width=0.8\textwidth,
            height=0.5\textwidth,
            ]
            \addplot[color=red,mark=*] coordinates {
                (0,0)
                (0.1,346.8105)
                (0.2,771.1143)
                (0.4,1644.2018)
                (0.6,2630.5735)
                (0.8,3509.2007)
                (1,4649.0550)
            };
            \addlegendentry{AVL}
            \addplot[color=green,mark=square] coordinates {
                (0,0)
                (0.1,154.9507)
                (0.2,332.5638)
                (0.4,704.9692)
                (0.6,1089.7851)
                (0.8,1488.7917)
                (1,1934.7171)
            };
            \addlegendentry{std::map}
        \end{axis}
    \end{tikzpicture}
    \label{fig:graph}
\end{figure}

\begin{figure}[htbp]
    \centering
    \caption*{Поиск} 
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Объём входных данных ($\times 10^5$)},
            ylabel={Время работы (ms)},
            grid=major,
            xmin=0, xmax=1,
            ymin=0, ymax=5000,
            xtick={0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1},
            ytick={0,500,1000,1500,2000,2500,3000,3500,4000,4500,5000},
            legend style={at={(0.5,-0.2)},anchor=north},
            legend columns=2,
            width=0.8\textwidth,
            height=0.5\textwidth,
            ]
            \addplot[color=red,mark=*] coordinates {
                (0,0)
                (0.1,205.2384)
                (0.2,501.1573)
                (0.4,1212.0937)
                (0.6,2374.2948)
                (0.8,3192.5832)
                (1,4120.5739)
            };
            \addlegendentry{AVL}
            \addplot[color=green,mark=square] coordinates {
                (0,0)
                (0.1,297.1044)
                (0.2,726.5728)
                (0.4,1405.1106)
                (0.6,2805.2644)
                (0.8,3592.8732)
                (1,4502.1294)
            };
            \addlegendentry{std::map}
        \end{axis}
    \end{tikzpicture}
    \label{fig:graph}
\end{figure}

\newpage
\subsection*{Выводы}

%Описать область применения реализованного алгоритма. Указать типовые задачи, решаемые им. Оценить сложность программирования, кратко описать возникшие проблемы при решении задачи. 

В результате данной лабораторной работы была написана и отлажена программа на языке C++, реализующая AVL-дерево, на основе которого разработана программа-словарь. В словаре каждому ключу, представляющему из себя регистронезависимую последовательность букв английского алфавита длиной не более 256 символов, поставлен в соответствие некоторый номер, от 0 до ${2^{64} - 1}$.

Сложность моей реализации словаря на основе AVL-дерева близка к ${O}(nlog(n))$, где n \textbf{--} высота дерева, что объективно хуже, что ${O}(log(n))$. Мне кажется, это связано с тем, что я довольно часто выделяю/освобождаю память на куче, что снижает эффективность программы. Также я храню строки, у которых тоже происходит частое выделение/освобождение памяти. 

В общем случае, AVL-деревья очень важны и применяются довольно часто. Благодаря сбалансированности и борьбе с вырождением дерева информация в нем хранится более эффективно. Поэтому доступ к данным оказывается быстрее и найти их становится легче.

\end{document}

